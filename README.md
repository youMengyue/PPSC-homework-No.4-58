# Демонстрация производительности инструкций SIMD

## Номер студента: 58

---

### 1. Итоговая инструкция: `_mm_div_pd`

В соответствии с заданием, на основе номера студента `58` была выбрана инструкция **`_mm_div_pd`** для демонстрации.

---

### 2. Цель программы и анализ результатов

Цель данной программы — корректно измерить и продемонстрировать прирост производительности от использования SIMD-инструкции `_mm_div_pd` по сравнению с настоящим последовательным (скалярным) кодом.

#### Проблема автовекторизации
При использовании стандартных флагов оптимизации (например, `-O3`), современные компиляторы автоматически преобразуют простые циклы в SIMD-код. Из-за этого сравнение ручного SIMD-кода с обычным циклом `for` не показывает реального ускорения, так как по факту сравниваются две SIMD-реализации.

Чтобы провести корректный эксперимент, мы компилируем скалярную версию с дополнительным флагом `-fno-tree-vectorize`, который **запрещает** компилятору выполнять автовекторизацию. Это гарантирует, что скалярный код будет выполняться строго последовательно.

#### Анализ производительности `_mm_div_pd`
После отключения автовекторизации для скалярной версии, мы наблюдаем ускорение. Однако, оно не достигает теоретического максимума в 2 раза. Это связано с тем, что сама по себе операция деления чисел с плавающей запятой (`double`) является аппаратно очень медленной (имеет высокую задержку, *latency*).

Таким образом, даже в SIMD-версии основным "бутылочным горлышком" становится не скорость загрузки/выгрузки данных, а время, которое процессор тратит на выполнение самой операции деления. SIMD позволяет сократить накладные расходы на организацию цикла, но не может ускорить сам аппаратный делитель.

Для сравнения, если бы мы использовали быструю операцию, такую как умножение (`_mm_mul_pd`), ускорение было бы значительно ближе к теоретическому двукратному.

---

### 3. Как скомпилировать и запустить

Проект использует `Makefile` для управления сборкой.

1.  **Запуск теста (с отключенной автовекторизацией для скалярной версии)**:
    Эта команда покажет **реальную** разницу в производительности.
    ```bash
    make run_no_vec
    ```

2.  **Запуск стандартного теста (с включенной автовекторизацией)**:
    Эта команда покажет, что компилятор сам отлично оптимизирует простой код.
    ```bash
    make run
    ```

3.  **Очистка**:
    ```bash
    make clean
    ```
